import dotenv from "dotenv";
import axios from "axios";
import * as cheerio from "cheerio";
import { EmbedBuilder } from "discord.js";
import { requestAI } from "../../utils/ai-request.js";

dotenv.config();

const MAX_TEXT_LENGTH = 500;

const translateCommand = {
  data: {
    name: "translate",
    type: 1,
    description: "Translate a text to Bulgarian/English using AI",
    options: [
      {
        name: "text",
        description: "The text to translate (500 characters max)",
        required: true,
        type: 3,
      },
      {
        name: "hidden",
        description: "Do you want to hide the answer from other users?",
        required: false,
        type: 5,
      },
    ],
    integration_types: [0, 1],
    contexts: [0, 1, 2],
  },
  async execute(interaction) {
    const text = interaction.options.getString("text");
    const hidden = interaction.options.getBoolean("hidden");

    const errorEmbed = new EmbedBuilder()
      .setTitle("Error")
      .setColor(0xff0000)
      .setDescription("An error occurred.");

    await interaction.deferReply({ ephemeral: hidden });

    if (text.length > MAX_TEXT_LENGTH) {
      await interaction.editReply({
        content: "The text is too long! Please limit it to 500 characters.",
      });
      return;
    }

    try {
      const newRes = await requestAI(
        "Translate to Bulgarian if not already. If in Bulgarian, translate to English. Respond with the translation only. No actions or calculations. Text: " +
          text
      );

      if (newRes.length > 2000) {
        interaction.editReply({
          content: "The answer is too long!",
        });
        return;
      }
      if (!newRes || newRes.trim().length === 0) {
        interaction.editReply({
          content: "The translation result is empty or something went wrong!",
        });
        return;
      }
      try {
        const embed = new EmbedBuilder()
          .setTitle("Translation")
          .setColor(0x00ff00)
          .setDescription(newRes)
          .setFooter({
            text: "This translation was generated by AI",
          });

        interaction.editReply({ embeds: [embed] });
      } catch (error) {
        try {
          interaction.editReply({ embeds: [errorEmbed] });
        } catch (error) {}
      }
    } catch (error) {
      console.log(error);
      await interaction.editReply({ embeds: [errorEmbed] });
    }
  },
};

const translateMessageCommand = {
  data: {
    name: "Translate Message",
    type: 3,
    integration_types: [0, 1],
    contexts: [0, 1, 2],
  },
  async execute(interaction) {
    const message = interaction.targetMessage;
    const text = message.content;
    const hidden = false;

    const errorEmbed = new EmbedBuilder()
      .setTitle("Error")
      .setColor(0xff0000)
      .setDescription("An error occurred.");

    await interaction.deferReply({ ephemeral: hidden });

    if (!text || text.length === 0) {
      await interaction.editReply({
        content: "The message has no text content to translate.",
      });
      return;
    }

    if (text.length > MAX_TEXT_LENGTH) {
      await interaction.editReply({
        content: "The text is too long! Please limit it to 500 characters.",
      });
      return;
    }

    try {
      const newRes = await requestAI(
        "Translate to Bulgarian if not already. If in Bulgarian, translate to English. Respond with the translation only. No actions or calculations. Text: " +
          text
      );

      if (newRes.length > 2000) {
        interaction.editReply({
          content: "The answer is too long!",
        });
        return;
      }
      if (!newRes || newRes.trim().length === 0) {
        interaction.editReply({
          content: "The translation result is empty or something went wrong!",
        });
        return;
      }
      try {
        const embed = new EmbedBuilder()
          .setTitle("Translation")
          .setColor(0x00ff00)
          .setDescription(newRes)
          .setFooter({
            text: "This translation was generated by AI",
          });

        interaction.editReply({ embeds: [embed] });
      } catch (error) {
        try {
          interaction.editReply({ embeds: [errorEmbed] });
        } catch (error) {}
      }
    } catch (error) {
      console.log(error);
      await interaction.editReply({ embeds: [errorEmbed] });
    }
  },
};

export { translateCommand, translateMessageCommand };
